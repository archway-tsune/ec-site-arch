# 機能仕様書: サンプル・本番分離アーキテクチャ

**フィーチャーブランチ**: `003-decouple-samples`
**作成日**: 2026-02-08
**ステータス**: ドラフト
**入力**: 本番コード（APIルート・ページ・インフラ層）がサンプル実装（src/samples/）に直接依存している構造を解消し、サンプルを参照用として完全に独立させるアーキテクチャ修正。

## ユーザーシナリオとテスト *(必須)*

### ユーザーストーリー 1 - リポジトリインターフェースの共有契約への集約 (優先度: P1)

開発者がドメインのリポジトリインターフェース（ProductRepository, CartRepository, OrderRepository, ProductFetcher, CartFetcher）を、サンプルのユースケースファイルではなく共有の契約層（src/contracts/）から参照できるようにする。インフラ層（src/infrastructure/repositories/）の import 先を共有契約に変更し、サンプルのユースケースファイルへの直接依存を排除する。

**この優先度の理由**: リポジトリインターフェースはインフラ層・APIルート・ページすべての基盤となる。これを先に分離しないと後続のストーリーが成立しない。

**独立テスト**: 共有契約にインターフェースを移動し、インフラ層の import 先を変更した後、型チェック（pnpm typecheck）と既存の単体テスト（pnpm test:unit）がすべて通ることで検証できる。

**受入シナリオ**:

1. **前提** サンプルのユースケースファイル内にリポジトリインターフェースが定義されている, **操作** 共有契約層にインターフェースを移動する, **結果** src/contracts/ にリポジトリインターフェースが存在し、サンプルのユースケースファイルからは共有契約を参照している
2. **前提** インフラ層がサンプルのユースケースからリポジトリインターフェースを import している, **操作** import 先を共有契約に変更する, **結果** src/infrastructure/repositories/ の3ファイルが src/contracts/ からのみ型を import しており、@/samples/ への直接 import が存在しない
3. **前提** 共有契約に既存のDTOスキーマが定義されている, **操作** リポジトリインターフェースを追加する, **結果** 既存のDTOスキーマに変更がなく、リポジトリインターフェースのみが追加されている

---

### ユーザーストーリー 2 - APIルートの参照先分離 (優先度: P2)

開発者が本番ドメイン層（src/domains/）を唯一の参照先として、APIルートからサンプル実装への直接依存を排除できるようにする。各ドメインの本番ユースケースが未実装の場合は、暫定スキャフォールドがサンプルと同じ機能を提供し、アプリケーションの動作を維持する。

**この優先度の理由**: APIルートは7ファイルと最も多くのファイルがサンプルに依存しており、バックエンドの分離を優先することでフロントエンドの分離が容易になる。

**独立テスト**: APIルートの import 先を @/domains/ に変更し、暫定スキャフォールドを配置した後、型チェックと既存テスト（単体・統合・E2E）がすべて通ることで検証できる。

**受入シナリオ**:

1. **前提** APIルートが @/samples/domains/ からユースケース関数を import している, **操作** import 先を @/domains/ に変更し暫定スキャフォールドを配置する, **結果** 7つのAPIルートファイルすべてが @/domains/ からのみ import しており、@/samples/ への直接 import が存在しない
2. **前提** 暫定スキャフォールドが配置されている, **操作** 既存のAPI操作（商品一覧取得、カート操作、注文作成等）を実行する, **結果** 修正前と同一の応答が返り、既存の動作が維持されている
3. **前提** 暫定スキャフォールドが配置されている, **操作** 開発者が本番ユースケースを実装して暫定スキャフォールドを置き換える, **結果** APIルートの import パスを変更せずに本番実装に切り替わる

---

### ユーザーストーリー 3 - ページコンポーネントの参照先分離 (優先度: P3)

開発者がページコンポーネントからサンプルのUIコンポーネントへの直接依存を排除できるようにする。APIルートと同様に、本番UIが未実装の場合は暫定スキャフォールドがサンプルと同じ表示を提供する。

**この優先度の理由**: ページの分離はAPIルートの分離と同じパターンで実施でき、5ファイルが対象。バックエンド（P2）の後に実施することで、フロントエンドとバックエンドの整合性を保てる。

**独立テスト**: ページの import 先を @/domains/ に変更し、暫定スキャフォールドを配置した後、型チェックと既存テストがすべて通ることで検証できる。

**受入シナリオ**:

1. **前提** ページが @/samples/domains/ からUIコンポーネントを import している, **操作** import 先を @/domains/ に変更し暫定スキャフォールドを配置する, **結果** 5つのページファイルすべてが @/domains/ からのみ import しており、@/samples/ への直接 import が存在しない
2. **前提** 暫定スキャフォールドが配置されている, **操作** 各ページ（カタログ一覧・詳細、カート、注文一覧・詳細）を表示する, **結果** 修正前と同一の画面が表示され、既存の動作が維持されている

---

### ユーザーストーリー 4 - リリースZIPへのテスト同梱 (優先度: P4)

開発者がリリースZIPを展開した際に、アーキテクチャE2Eテストの実装パターンを参照できるようにする。ただし、ZIP展開先のプロジェクトではアーキテクチャE2Eは実行されず、参照専用となる。アーキテクチャリポジトリではPR作成時にアーキテクチャE2Eが実行される。

**この優先度の理由**: テストの同梱は分離作業の本体（P1-P3）とは独立した改善であり、開発者体験の向上が目的。

**独立テスト**: リリースZIPを作成し、テストファイルの同梱状況とCI動作を確認することで検証できる。

**受入シナリオ**:

1. **前提** リリースZIPからアーキテクチャE2Eテスト（tests/e2e/arch/）が除外されている, **操作** リリースZIP生成スクリプトを修正する, **結果** 生成されたZIPにtests/e2e/arch/のテストファイルが含まれている
2. **前提** リリースZIPにアーキテクチャE2E設定（playwright.arch.config.ts）が含まれていない, **操作** ZIP展開先でCIを実行する, **結果** アーキテクチャE2Eは実行されず、テストファイルは参照専用として存在する
3. **前提** アーキテクチャリポジトリにplaywright.arch.config.tsが存在する, **操作** PRを作成する, **結果** CIでアーキテクチャE2Eテストが実行される

---

### ユーザーストーリー 5 - ドキュメント・入力例の更新 (優先度: P5)

開発者がプロジェクトドキュメントと機能入力例を参照した際に、新しいアーキテクチャ構造（@/domains/ を起点とした本番実装、共有契約層の活用）に基づいた正確な情報を得られるようにする。

**この優先度の理由**: ドキュメント更新は分離作業の完了後に実施する仕上げ作業であり、コードの動作には影響しない。

**独立テスト**: 更新後のドキュメントに @/samples/ を直接参照する開発手順が残っていないことをテキスト検索で確認できる。

**受入シナリオ**:

1. **前提** プロジェクトドキュメントがサンプル依存の旧構造を前提に記述されている, **操作** 各ドキュメントを新構造に合わせて更新する, **結果** README.md、GETTING_STARTED.md、SPECKIT_INTEGRATION.md、domains/README.md、samples/README.md、scripts/README.md、quickstart.md が新構造を反映している
2. **前提** 機能入力例の plan 入力がサンプルからの移行を前提に記述されている, **操作** @/domains/ の暫定スキャフォールドをベースにした記述に変更する, **結果** constitution-example.md および4つの機能入力例（catalog, cart, order, product）が新構造を反映している

---

### エッジケース

- サンプルのユースケースファイルがリポジトリインターフェースと同名の型を内部的に使用している場合、共有契約への移動後もサンプル内の型参照が正しく解決されるか
- 暫定スキャフォールドの再エクスポートにより、Tree Shaking やバンドルサイズに悪影響が出ないか
- サンプルと共有契約の間で循環依存が発生しないか
- 暫定スキャフォールドを部分的に本番実装に置き換えた状態（1ドメインだけ本番実装、残りは暫定）で正常に動作するか

## 要件 *(必須)*

### 機能要件

- **FR-001**: 共有契約層（src/contracts/）にリポジトリインターフェース（ProductRepository, CartRepository, OrderRepository, ProductFetcher, CartFetcher）が定義されていること
- **FR-002**: インフラ層（src/infrastructure/repositories/）の3ファイルが共有契約からのみリポジトリインターフェースを import していること
- **FR-003**: サンプルのユースケースファイルが共有契約からリポジトリインターフェースを参照し、インラインでの定義を持たないこと
- **FR-004**: 7つのAPIルートファイルが @/domains/ からのみユースケース関数・エラークラスを import していること
- **FR-005**: 5つのページファイルが @/domains/ からのみUIコンポーネントを import していること
- **FR-006**: 本番ドメイン層（src/domains/）に各ドメイン（catalog, cart, orders）の暫定スキャフォールドが存在し、サンプルと同一のインターフェースを公開していること
- **FR-007**: 暫定スキャフォールドを本番実装に置き換える際、APIルート・ページの import パスを変更する必要がないこと
- **FR-008**: リリースZIPにアーキテクチャE2Eテスト（tests/e2e/arch/）のファイルが含まれていること
- **FR-009**: リリースZIPにアーキテクチャE2E設定（playwright.arch.config.ts）が含まれていないこと
- **FR-010**: 共有契約の既存DTOスキーマが変更されていないこと（リポジトリインターフェースの追加のみ）
- **FR-011**: 修正前後でアプリケーションの動作（APIレスポンス、画面表示）が同一であること
- **FR-012**: プロジェクトドキュメント（7ファイル）と機能入力例（5ファイル）が新構造を反映していること

### 主要エンティティ

- **共有契約（src/contracts/）**: DTOスキーマ（既存）とリポジトリインターフェース（新規追加）を含む、サンプル・本番の両方が参照する型定義の集約層
- **本番ドメイン層（src/domains/）**: 各ドメインの本番実装を配置する層。初期状態では暫定スキャフォールドとしてサンプルの機能を再公開し、段階的に本番実装に置き換えられる
- **サンプル実装（src/samples/）**: 参照・学習用のリファレンス実装。本修正後は本番コードから直接参照されず、独立して存在する

## 成功基準 *(必須)*

### 計測可能な成果

- **SC-001**: src/app/、src/infrastructure/ 配下の全ファイルにおいて、@/samples/ への直接 import が0件であること
- **SC-002**: 修正前後で型チェック（pnpm typecheck）がエラー0件で通ること
- **SC-003**: 修正前後で既存の全テスト（単体・統合・E2E）が通ること
- **SC-004**: 暫定スキャフォールドを1ドメインずつ本番実装に置き換えた各段階で、型チェックとテストが通ること
- **SC-005**: リリースZIPにtests/e2e/arch/のテストファイルが含まれ、playwright.arch.config.tsが含まれていないこと
- **SC-006**: ZIP展開先のプロジェクトでCIを実行した際にアーキテクチャE2Eが実行されないこと

## スコープ外

- サンプル実装の機能・振る舞いの変更（構造的な修正のみ行う）
- 新しいドメイン機能の追加
- 暫定スキャフォールドの本番実装への置き換え（本修正では暫定状態までを対象とする）
- テストの新規追加（既存テストの維持のみ）

## 前提条件

- サンプル実装（src/samples/）の仕様（機能・振る舞い）は変更しないが、import パスの変更等の構造的な修正は行う
- 共有契約（src/contracts/）の既存DTOスキーマは変更しない（リポジトリインターフェースの追加のみ）
- 本修正は機能追加ではなく、既存動作を維持したままの内部リファクタリングである
- アーキテクチャリポジトリのCI（ci.yml）はplaywright.arch.config.tsの存在でアーキテクチャE2Eの実行を判定している
